<!-- Application -->
<app>

    <div id="tabs-selector"></div>
    <div id="tabs"></div>

    <script>
        let self = this;

        /* global RiotControl ACTION */
        let rc = RiotControl;

        self.remote = require("electron").remote;

        // 新規タブのオープン
        RiotControl.on(ACTION.TAB_OPEN,
            function(path){
                if (!path) {
                    return;
                }
                console.log(path);
                let tabs = jquery("#tabs");

                let sheet = MakeTable(tabs, path);
                let Konata = require("./Konata.js");
                let konataInternal = new Konata();
                try {

                    if (!konataInternal.OpenFile(path)) {
                        konataInternal.Close(path);
                        return;
                    }
                } catch(e) {
                    if (e == "Wait") {
                        //console.log(path, " extract waiting..,");
                        //let self = this;
                        //setTimeout(self.Draw(path), 10000);
                    }
                    else{
                        return;
                    }
                }
                
                if (konata.InitDraw(path, konataInternal, sheet)) {
                    SetControl(tabs);
                    WindowResize();
                    control.tabnum++;
                    CreateTabMenu(path);
                    SetZIndex(path, control.tabnum);
                    control.bind[path] = [];
                    MoveFront(index.path);
                    MoveFront(path);
                    index.path = path;
                }
            }
        );

        // タブのクローズ
        rc.on(ACTION.TAB_CLOSE,
            function(path){
                konata.Close(path);
                jquery('[data-path="' + path + '"]').remove();
            }
        );

        // 初期化
        // マウント時に呼ばれる
        self.init = function(){
            // メニューを追加
            /* global installMenu */
            installMenu();
        };

        // エントリポイント
        self.on("mount", self.init);


        // オリジナル実装
        let jquery = jQuery;

        let KonataRenderer = require("./KonataRenderer.js");
        let konata = new KonataRenderer();

        const remote = require("electron").remote;
        const Menu = remote.Menu;
        const MenuItem = remote.MenuItem;



        // 現在アクティブなタブの情報
        let index = {
            id: 0,
            order: 0,
            path: null
        };


        let p_menu = new Menu();
        p_menu.append(new MenuItem({ label: '全体を半透明化', click: function() { Transparent(true); } }));
        p_menu.append(new MenuItem({ label: '背景だけ透明化', click: function() { Transparent(true, true); } }));
        p_menu.append(new MenuItem({ label: '透明化を解除', click: function() { Transparent(false); } }));
        p_menu.append(new MenuItem({ label: '全体を橙色に', click: function() { Color("#f80"); } }));
        p_menu.append(new MenuItem({ label: '全体を青色に', click: function() { Color("#08f"); } }));
        p_menu.append(new MenuItem({ label: 'デフォルトの配色', click: function() { Color(null); } }));

        let control = {};
        control.name = "Controler name space";
        control.mouse = false;
        control.mouseX = [];
        control.mouseY = [];
        control.resizeing = false;
        control.tabnum = 0;
        control.bind = {};


        // 新しいタブのためのラベルやスプリッタ，描画の DOM を生成する
        function MakeTable(obj, path){
            // pathは空白なしに変換する(HTMLの一般的な属性値に空白文字を利用できないため)
            let noSpacePath = path; // 面倒臭い．
            let tab = jquery("<div></div>", {"class":"tab"}).appendTo(obj);
            tab.attr("id", "Konata_" + noSpacePath);
            tab.attr("data-path", path);
            jquery("<span></span>", {"class":"labels-window"}).appendTo(tab);
            jquery("<span></span>", {"class":"window-sizing"}).appendTo(tab);
            jquery("<span></span>", {"class":"pipelines-window"}).appendTo(tab);
            console.log("Make tab");
            return tab;
        }

        function SetZIndex(path, z, relative){
            let tabs = jquery("#tabs");
            let tab = tabs.find('[data-path="' + path + '"]');
            if (!relative) {
                if (tab.data("zIndex") == z) {
                    return false;
                }
            }
            if (relative) {
                z += parseInt(tab.data("zIndex"));
            }
            tab.find("*").css("zIndex", z);
            tab.css("zIndex", z);
            tab.data("zIndex", z);
            return true;
        }

        function NextTab(dir) {
            let tabs = jquery("#tabs");
            let tab = tabs.find('[data-path="' + index.path + '"]');
            let next;
            if (dir) {
                next = tab.next();
            } else {
                next = tab.prev();
            }
            if (next.length == 0) {
                if (dir) {
                    next = tabs.find(".tab").first();
                } else {
                    next = tabs.find(".tab").last();
                }    
            }
            let path = next.attr("data-path");
            if(path) {
                MoveFront(path);
            }
        }

        function Bind(path) {
            //let path = control.temp;
            if (index.path == path) {
                return;
            }
            if (control.bind[index.path]) {
                console.log(control.bind[index.path]);
            }
            let i = jquery.inArray(path, control.bind[index.path]);
            if (i < 0) {
                control.bind[index.path].push(path);
            }
        }

        function Release(path) {
            //let path = control.temp;
            let i = jquery.inArray(path, control.bind[index.path]);
            if (i > -1) {
                control.bind[index.path].splice(i, 1);
            }

        }

        function Color(color) {
            konata.ParentStyle(index.path, "color", color);
            konata.Draw(index.path);
        }

        function Transparent (enable, all) {
            let tabs = jquery("#tabs");
            let tab = tabs.find('[data-path="' + index.path + '"]');
            if (enable) {
                if (!all) {
                    SetOpacity(0.5);
                } else {
                    SetOpacity(1);
                }
                tab.find("*").css("background-color", "transparent");
            } else {
                SetOpacity(1);
                tab.find("*").css("background-color", "#fff");
            }
        }

        function SetOpacity(alpha) {
            let tabs = jquery("#tabs");
            let tab = tabs.find('[data-path="' + index.path + '"]');
            konata.ParentStyle(index.path, "opacity", alpha);
            konata.Draw(index.path);
        }

        function CreateTabMenu (path) {
            let array = path.split("/");
            let shortPath = array[array.length - 1]; // なんかタブ上に表示できる程度に加工した名前にしたい。
            let tabs = jquery("#tabs-selector");
            let tab = jquery("<span>" + shortPath + "</span>").appendTo(tabs);
            let close = jquery("<span>X</span>").appendTo(tab);
            close.addClass("close");
            tabs = tabs.find(".tab-selector");
            tab.attr("data-path", path);
            tab.addClass("tab-selector");

            // コンテキストメニューの内容
            let t_menu = new Menu();
            t_menu.append(new MenuItem({label: "スクロール・ズームを連携", 
                click: function() {
                    Bind(path);
                }
            }));
            t_menu.append(new MenuItem({label: "連携を解除",
                click:function() {
                    Release(path);
                }
            }));

            // 各種イベントを設定
            tab.click(function () {
                MoveFront(path);
            });
            // 右クリック
            tab.contextmenu(function () {
                t_menu.popup(remote.getCurrentWindow());
            });
            close.click(function() {
                Close(path);
            });
        }

        function MoveFront(path) {
            let tabs = jquery("#tabs-selector").find(".tab-selector");
            if (!SetZIndex(path, control.tabnum)) {
                return; // 既に最前面にある。
            }
            index.path = path; // 操作するタブを自身に変更。
            // 自身以外のタブを一つずつ後ろに移動。
            tabs.each (function(i, box) {
                let t = jquery(box);
                let p = t.attr("data-path");
                if (p == path) {
                    t.css("background-color", "#ddd");
                    t.css("min-height", 20);
                } else {
                    SetZIndex(p, -1, true);
                    t.css("background-color", "#fff");
                    t.css("min-height", 18);
                }
            });
        }


        function WindowResize(draw) {
            let tab = jquery(".tab");
            if (tab.length == 0) {
                return;
            }
            let l_window = tab.find(".labels-window");
            let p_window = tab.find(".pipelines-window");
            let w_sizing = tab.find(".window-sizing");
            let offset = w_sizing.offset();
            let l_width = offset.left - parseInt(l_window.css("left"));
            let p_left = offset.left + parseInt(w_sizing.css("width"));
            let p_width = jquery(window).width() - p_left - 5;
            l_window.css("width", l_width + "px");
            p_window.css("left", p_left + "px");
            p_window.css("width", p_width + "px");
            let path = index.path;
            if (draw) {
                konata.Draw(path,jquery("#tabs"));
            }
        }

        function Zoom(dir) {
            if (control.resizeing) {
                return;
            }
            control.resizeing = true;
            let scale = 0;
            if (dir) {
                scale = 2;
            } else {
                scale = 0.5;
            }
            konata.Zoom(index.path, scale);
            for (let i = 0, len = control.bind[index.path].length; i < len; i++) {
                let path = control.bind[index.path][i];
                konata.Zoom(path, scale);
            }
            control.resizeing = false;
        }

        function MoveTo (diff, adjust) {
            konata.MoveTo(diff, index.path, adjust);
            for (let i = 0, len = control.bind[index.path].length; i < len; i++) {
                let path = control.bind[index.path][i];
                konata.MoveTo(diff, path, adjust);
            }
        }

        document.ondragover = function(e) {
            e.preventDefault(); // イベントの伝搬を止めて、アプリケーションのHTMLとファイルが差し替わらないようにする
            return false;
        };

        jquery(window).ready(function(){
            jquery(window).resize(function() {
                WindowResize();
            });
            WindowResize();

            document.ondrop = function (e) {
                e.preventDefault(); // イベントの伝搬を止めて、アプリケーションのHTMLとファイルが差し替わらないようにする
                let file = e.dataTransfer.files[0];
                Send(file.path);
            };
        });

        function SetControl (tab) {
            if (tab.length == 0) {
                return;
            }
            let l_window = tab.find(".labels-window");
            let p_window = tab.find(".pipelines-window");
            let w_sizing = tab.find(".window-sizing");

            p_window.scroll (function() {
                // ラベルウィンドウとパイプラインウィンドウのスクロールを同期
            });
            p_window.dblclick(function(){
                console.log("Double click!");
                Zoom(true);
            });
            p_window.contextmenu(function(){
                console.log("Context menu");
                p_menu.popup(remote.getCurrentWindow());
            });
            p_window.mousewheel(function(e, delta, deltaX, deltaY){
                if (event.preventDefault) {
                    // デフォルトのスクロール処理をキャンセル
                    event.preventDefault();
                }
                if (e.ctrlKey) {
                    if (deltaY > 0) {
                        Zoom(true);
                    } else {
                        Zoom(false);
                    }
                } else {
                    let scroll = 3/konata.GetScale(index.path);
                    if (deltaY < 0) {
                        deltaY = scroll;
                    } else {
                        deltaY = -scroll;
                    }
                    if (deltaX < 0) {

                    } else {

                    }
                    MoveTo({top:deltaY, left:0}, true);
                }
            });
            OnDrag(p_window);

            w_sizing.draggable({
                axis:'x'
            });
            w_sizing.on("drag",function() {
                WindowResize(false);
            });
            w_sizing.on("dragstop",function() {
                WindowResize(true);
            });
            

            l_window.mousewheel(function(e, delta, deltaX, deltaY){
            });
            l_window.scroll (function() {
                // ラベルウィンドウとパイプラインウィンドウのスクロールを同期
            });
            l_window.dblclick(function(){
                //Zoom(true);
            });
        }

        function Sum(array) {
            let sum = 0;
            for (let i = 0, len = array.length; i < len; i++) {
                sum += array[i];
            }
            return sum;
        }

        function OnDrag (obj) {
            obj.on("mousedown", function (e) {
                control.mouse = true;
                control.mouseX = [e.screenX];
                control.mouseY = [e.screenY];
            });
            obj.on("mousemove", function (e) {
                if (control.mouse) {
                    let oldX = Average(control.mouseX);
                    let oldY = Average(control.mouseY);
                    control.mouseY.push(e.screenY); // 値に多少のブレがあっても平滑化すればいいかなと。
                    control.mouseX.push(e.screenX); // 今となってはあまり意味がないかもしれない。
                    if (control.mouseX.length > 1) {
                        control.mouseX.shift();
                    }
                    if (control.mouseY.length > 1) {
                        control.mouseY.shift();
                    }
                    let diffY = Average(control.mouseY) - oldY;
                    let diffX = Average(control.mouseX) - oldX;
                    diffX = -diffX/25/konata.GetScale(index.path);
                    diffY = -diffY/25/konata.GetScale(index.path);
                    MoveTo({left:diffX, top:diffY},  null);
                }
            });
            obj.on("mouseup", function(e){
                //if (control.mouse) {
                //}
                control.mouse = false;
            });
            obj.on("mouseleave", function(e){
            });
        }

        function Average (array) {
            return Sum(array)/array.length;
        }


    </script>
</app>


